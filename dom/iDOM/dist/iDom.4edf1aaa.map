{"version":3,"sources":["iDom.js"],"names":["window","dom","string","container","document","createElement","innerHTML","trim","content","firstChild","nodeForPositioning","nodeToInsert","parentNode","insertBefore","nextSibling","childNode","appendChild","before","append","node","removeChild","text","childNodes","array","length","i","push","remove","name","value","arguments","setAttribute","toString","getAttribute","innerText","constructor","Object","style","String","newClass","classList","add","classToRemove","event","fn","addEventListener","removeEventListener","selector","range","querySelectorAll","textNode","children","Array","from","filter","n","next","nodeType","previousSibling","prev","nodeList","call","index","indexWithText","console","log"],"mappings":";AA2VA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,CAAA,IAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,QAAA,EAAA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,OAAA,MAAA,KAAA,GA3VAA,OAAOC,IAAM,CAAA,OAMJC,SAAAA,GAECC,IAAAA,EAAYC,SAASC,cAAc,YAGlCF,OADGG,EAAAA,UAAYJ,EAAOK,OACtBJ,EAAUK,QAAQC,YAXhB,MAsBLC,SAAAA,EAAoBC,GACLC,EAAAA,WAAWC,aAC5BF,EACAD,EAAmBI,cAzBZ,OAqCJJ,SAAAA,EAAoBC,GACNC,EAAAA,WAAWC,aAC5BF,EACAD,IAxCO,OAkDJE,SAAAA,EAAYG,GACVH,OAAAA,EAAWI,YAAYD,IAnDrB,KA4DNA,SAAAA,EAAWH,GACVK,IAAAA,OAAOF,EAAWH,GAClBM,IAAAA,OAAON,EAAYG,IA9Dd,OAsEJI,SAAAA,GAEEA,OADFP,EAAAA,WAAWQ,YAAYD,GACrBA,GAxEE,MAiFLA,SAAAA,GAKC,IALKE,IAAAA,EAAO,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAETC,EAAeH,EAAfG,WACFC,EAAQ,GACRC,EAASF,EAAWE,OACjBC,EAAIJ,EAAO,EAAI,EAAGI,EAAID,EAAQC,IAC/BC,EAAAA,KAAKzB,IAAI0B,OAAOL,EAAWD,EAAO,EAAI,KAEvCE,OAAAA,GAzFE,KAoGNJ,SAAAA,EAAMS,EAAMC,GACXC,OAAqB,IAArBA,UAAUN,QACPO,EAAAA,aAAaH,EAAKI,WAAYH,GAC5BV,GACuB,IAArBW,UAAUN,OACZL,EAAKc,aAAaL,EAAKI,iBADzB,GAxGE,KAoHNb,SAAAA,EAAMU,GACLC,OAAqB,IAArBA,UAAUN,QACPU,EAAAA,UAAYL,EAAMG,WAChBb,GACuB,IAArBW,UAAUN,OACZL,EAAKe,eADP,GAxHE,KAoINf,SAAAA,EAAMU,GACLC,OAAqB,IAArBA,UAAUN,QACPlB,EAAAA,UAAYuB,EAAMG,WAChBb,GACuB,IAArBW,UAAUN,OACZL,EAAKb,eADP,GAxIE,MAwJLa,SAAAA,GAASU,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAO,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GAChBA,GAAiB,IAAjBA,EAAML,OAAc,CAElBK,GAAAA,EAAM,GAAGM,cAAgBC,OAAQ,CAE9BX,IAAAA,KAAKI,EAAM,GACTQ,EAAAA,MAAMZ,GAAKI,EAAM,GAAGJ,GAEpBN,OAAAA,EACF,GAAIU,EAAM,GAAGM,cAAgBG,OAE3BnB,OAAAA,EAAKkB,MAAMR,EAAM,SAErB,GAAqB,IAAjBA,EAAML,OAGRL,OADFkB,EAAAA,MAAMR,EAAM,IAAMA,EAAM,GACtBV,GAxKA,SAkLFA,SAAAA,GAASoB,IAAU,IAAA,EAAVA,EAAAA,UAAAA,OAAAA,EAAU,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GAGnBpB,OADFqB,EAAAA,EAAAA,WAAUC,IAAOF,MAAAA,EAAAA,EAAAA,IACfpB,GArLE,YA8LCA,SAAAA,GAASuB,IAAe,IAAA,EAAfA,EAAAA,UAAAA,OAAAA,EAAe,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GAG3BvB,OADFqB,EAAAA,EAAAA,WAAUb,OAAUe,MAAAA,EAAAA,EAAAA,IAClBvB,GAIF,MAAA,CAAA,IACDA,SAAAA,GAASoB,IAAU,IAAA,EAAVA,EAAAA,UAAAA,OAAAA,EAAU,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GAGdpB,OADFqB,EAAAA,EAAAA,WAAUC,IAAOF,MAAAA,EAAAA,EAAAA,IACfpB,GAJJ,OAMEA,SAAAA,GAASuB,IAAe,IAAA,EAAfA,EAAAA,UAAAA,OAAAA,EAAe,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GAGtBvB,OADFqB,EAAAA,EAAAA,WAAUb,OAAUe,MAAAA,EAAAA,EAAAA,IAClBvB,IA9MA,GAyNRA,SAAAA,EAAMwB,EAAOC,GACPzB,OAAAA,EAAK0B,iBAAiBF,EAAOC,IA1N3B,IAoOPzB,SAAAA,EAAMwB,EAAOC,GACRzB,OAAAA,EAAK2B,oBAAoBH,EAAOC,IArO9B,KA8ONG,SAAAA,GACIC,OADc5C,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAAA,UACR6C,iBAAiBF,IA/OrB,OAwPJ5B,SAAAA,GACEA,OAAAA,EAAKP,YAzPH,SAkQFO,SAAAA,GACA+B,OADiB,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GACN/B,EAAKG,WAAaH,EAAKgC,UAnQhC,SA4QFhC,SAAAA,GACH+B,OADoB,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAEfE,MAAMC,KAAKlC,EAAKP,WAAWU,YAAYgC,OAAO,SAACC,GAAMA,OAAAA,IAAMpC,IAE3DiC,MAAMC,KAAKlC,EAAKP,WAAWuC,UAAUG,OAAO,SAACC,GAAMA,OAAAA,IAAMpC,KAhRzD,KA0RNA,SAAAA,GACC+B,GADgB,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAEX/B,OAAAA,EAAKL,YAGL0C,IADHA,IAAAA,EAAOrC,EAAKL,YACS,IAAlB0C,EAAKC,UACHD,EAAAA,EAAK1C,YAEP0C,OAAAA,GAlSA,SA4SFrC,SAAAA,GACH+B,GADoB,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAEf/B,OAAAA,EAAKuC,gBAGLC,IADHA,IAAAA,EAAOxC,EAAKuC,gBACS,IAAlBC,EAAKF,UACHE,EAAAA,EAAKD,gBAEPC,OAAAA,GApTA,KA6TNC,SAAAA,EAAUhB,GAAe,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAEvB,IAFYM,IACbC,EAAWS,EACNnC,EAAI,EAAGA,EAAI0B,EAAS3B,OAAQC,IAChCoC,EAAAA,KAAK,KAAMV,EAAS1B,KAhUhB,MA0ULN,SAAAA,GAAM+B,IAAAA,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GACjBY,EAAQ,EACVC,EAAgB,EACP5C,SAAAA,EAAKP,WAAWU,WACtB,IAAA,IAAIG,EAAI,EAAGA,EAAI0B,SAAS3B,SAC3BuC,IAC6B,IAAzBZ,SAAS1B,GAAGgC,UACdK,IAEEX,SAAS1B,KAAON,GALeM,KAS9ByB,OAAAA,EAAWa,EAAgBD,IAItCE,QAAQC,IAAI","file":"iDom.4edf1aaa.map","sourceRoot":"../src","sourcesContent":["window.dom = {\n  /** create\n   * 创建可嵌套的标签\n   * @param {string} string 标签字符串\n   * @returns 返回值：创建的嵌套元素的第一个子标签\n   */\n  create(string) {\n    //template标签可以容纳任意元素，不过其中的元素不能通过DOM直接获得\n    const container = document.createElement(\"template\");\n    //去除字符串中的所有空格\n    container.innerHTML = string.trim();\n    return container.content.firstChild;\n  },\n\n  /** after\n   * 在定位节点后插入新的兄弟节点\n   * DOM提供的insertBefore需要知道定位节点的父节点\n   * @param {Node} nodeForPositioning 定位节点\n   * @param {Node} nodeToInsert 要插入的节点\n   * @returns\n   * @example dom.after(node1, node2)\n   */\n  after(nodeForPositioning, nodeToInsert) {\n    nodeForPositioning.parentNode.insertBefore(\n      nodeToInsert,\n      nodeForPositioning.nextSibling\n    );\n  },\n\n  /** before\n   * 在定位节点前插入新的兄弟节点\n   * DOM提供的insertBefore需要知道定位节点的父节点\n   * @param {Node} nodeForPositioning 定位节点\n   * @param {Node} nodeToInsert 要插入的节点\n   * @returns\n   * @example dom.before(node1, node2)\n   */\n  before(nodeForPositioning, nodeToInsert) {\n    nodeForPositioning.parentNode.insertBefore(\n      nodeToInsert,\n      nodeForPositioning\n    );\n  },\n\n  /** append\n   * 在父节点下插入新的子节点\n   * @param {Node} parentNode 父节点\n   * @param {Node} childNode 要插入的子节点\n   * @returns\n   */\n  append(parentNode, childNode) {\n    return parentNode.appendChild(childNode);\n  },\n\n  /** wrap\n   * 将一个节点node移动到新的父节点parent下\n   * @param {Node} childNode 要移动的子节点\n   * @param {Node} parentNode 新的父节点\n   * @returns\n   */\n  wrap(childNode, parentNode) {\n    dom.before(childNode, parentNode);\n    dom.append(parentNode, childNode);\n  },\n\n  /** remove\n   * 删除一个节点,DOM同时移除其下的所有子节点，包括文本节点\n   * @param {Node} node 要删除的节点\n   * @returns 返回值：被删除的节点\n   */\n  remove(node) {\n    node.parentNode.removeChild(node);\n    return node;\n  },\n\n  /** empty\n   * 删除一个节点的所有子节点，但是保留该节点本身\n   * @param {Node} node 要操作的节点\n   * @param {boolean} text 是否删除这个节点本身的文本节点，默认为false\n   * @returns 返回值：被删除的子节点构成的数组\n   */\n  empty(node, text = false) {\n    //const childNodes = node.childNodes;\n    const { childNodes } = node;\n    const array = [];\n    const length = childNodes.length;\n    for (let i = text ? 0 : 1; i < length; i++) {\n      array.push(dom.remove(childNodes[text ? 0 : 1]));\n    }\n    return array;\n  },\n\n  /** attr\n   * 根据参数个数不同，修改或者获取一个节点的属性\n   * @param {*} node 一个节点\n   * @param {*} name 属性名\n   * @param {*} value 属性值\n   * 如果没有传递属性值，则获取对应属性的值；如果有传递属性值，则将属性的值修改为该值\n   * @returns 2个参数时：获取到的属性值；3个参数时：修改后的节点\n   */\n  attr(node, name, value) {\n    if (arguments.length === 3) {\n      node.setAttribute(name.toString(), value);\n      return node;\n    } else if (arguments.length === 2) {\n      return node.getAttribute(name.toString());\n    }\n  },\n\n  /** text\n   * 根据参数个数不同，修改或者获取一个节点下的文本节点内容\n   * @param {Node} node 一个节点\n   * @param {string} value 新的文本内容\n   * 如果没有传递value，则获取当前文本节点内容；如果有传递value，则将文本节点内容修改为该内容\n   * @returns 1个参数时：获取到的文本；2个参数时：修改后的节点\n   */\n  text(node, value) {\n    if (arguments.length === 2) {\n      node.innerText = value.toString();\n      return node;\n    } else if (arguments.length === 1) {\n      return node.innerText;\n    }\n  },\n\n  /** html\n   * 根据参数个数不同，修改或者获取一个节点下的HTML节点内容\n   * @param {Node} node 一个节点\n   * @param {string} value 新的HTML内容\n   * 如果没有传递value，则获取当前HTML节点内容；如果有传递value，则将HTML节点内容修改为该内容\n   * @returns 1个参数时：获取到的HTML；2个参数时：修改后的节点\n   */\n  html(node, value) {\n    if (arguments.length === 2) {\n      node.innerHTML = value.toString();\n      return node;\n    } else if (arguments.length === 1) {\n      return node.innerHTML;\n    }\n  },\n\n  /** style\n   * 功能1: 输入一个键字符串，获取一个节点的style对象中这个键对应的值\n   * 功能2: 输入一个键字符串和一个值字符串，修改一个节点的style对象中的对应键值对。\n   * 功能3: 输入一个对象，修改一个节点的style对象中的所有对应键值对。\n   * @param {Node} node 一个节点\n   * @param {Parameter} value 一个valueObject对象的键值对；或者一个键；或者一个键和一个值\n   * @returns 功能2，3: 一个键字符串和一个值字符串 => 修改后的节点; 功能1： style对象中这个键的值\n   * @examples 功能1使用例：dom.style(s1, \"border\")\n   * @examples 功能2使用例：dom.style(s1, \"border\", \"1px solid red\")\n   * @examples 功能3使用例：dom.style(s1, {\"border\":\"1px solid blue\", \"color\":\"pink\"})\n   */\n  style(node, ...value) {\n    if (value.length === 1) {\n      //对象时使用功能3\n      if (value[0].constructor === Object) {\n        //in语法遍历所有的键\n        for (i in value[0]) {\n          node.style[i] = value[0][i];\n        }\n        return node;\n      } else if (value[0].constructor === String) {\n        //字符串时使用功能1\n        return node.style[value[0]];\n      }\n    } else if (value.length === 2) {\n      //功能2\n      node.style[value[0]] = value[1];\n      return node\n    }\n  },\n\n  /** addClass\n   * 为一个节点添加class。多个class用逗号隔开。\n   * @param {Node} node 一个节点\n   * @param {...Parameters} newClass 多个class构成的数组\n   * @returns 修改后的节点\n   */\n  addClass(node, ...newClass) {\n    //将newClass展开为参数集\n    node.classList.add(...newClass);\n    return node;\n  },\n\n  /** removeClass\n   * 为一个节点移除class。多个class用逗号隔开。\n   * @param {Node} node 一个节点\n   * @param {...Parameters} classToRemove 要移除的class\n   * @returns 修改后的节点\n   */\n  removeClass(node, ...classToRemove) {\n    //将classToRemove展开为参数集\n    node.classList.remove(...classToRemove);\n    return node;\n  },\n\n  //提供一个综合的class对象实现上述添加移除的操作\n  class: {\n    add(node, ...newClass) {\n      //将newClass展开为参数集\n      node.classList.add(...newClass);\n      return node;\n    },\n    remove(node, ...classToRemove) {\n      //将classToRemove展开为参数集\n      node.classList.remove(...classToRemove);\n      return node;\n    },\n  },\n\n  /** on\n   * 给一个节点绑定事件\n   * @param {node} 待绑定事件的节点\n   * @param {event} 触发事件\n   * @param {fn} 回调函数\n   * @returns\n   */\n  on(node, event, fn) {\n    return node.addEventListener(event, fn);\n  },\n\n  /** off\n   * 移除一个事件的绑定函数\n   * @param {node} 绑定了事件的节点\n   * @param {event} 事件\n   * @param {fn} 回调函数\n   * @returns\n   */\n  off(node, event, fn) {\n    return node.removeEventListener(event, fn);\n  },\n\n  /** find\n   * 选择特定的节点，只能选择标签类节点\n   * @param {string} CSS形式的选择器\n   * @param {range} 可以预先指定一个有id属性的节点作为查找范围\n   * @returns NodeList\n   */\n  find(selector, range = document) {\n    return range.querySelectorAll(selector);\n  },\n\n  /** parent\n   * 选择特定的节点的父节点\n   * @param {string} CSS形式的选择器\n   * @param {range} 可以预先指定一个有id属性的节点作为查找范围\n   * @returns 父节点\n   */\n  parent(node) {\n    return node.parentNode;\n  },\n\n  /** children\n   * 获取特定的节点的所有子节点，\n   * @param {Node} node 一个节点\n   * @param {boolean} textNode 是否考虑文本节点，默认为false\n   * @returns 所有子节点构成的伪数组\n   */\n  children(node, textNode = false) {\n    return textNode ? node.childNodes : node.children;\n  },\n\n  /** siblings\n   * 获取一个节点的所有兄弟节点\n   * @param {Node} node 要操作的节点\n   * @param {boolean} textNode 是否考虑文本节点，默认为false\n   * @returns 所有兄弟节点组成的数组\n   */\n  siblings(node, textNode = false) {\n    if (textNode) {\n      return Array.from(node.parentNode.childNodes).filter((n) => n !== node);\n    } else {\n      return Array.from(node.parentNode.children).filter((n) => n !== node);\n    }\n  },\n\n  /** next\n   * 获取一个节点的下一个兄弟节点\n   * @param {Node} node 要操作的节点\n   * @param {boolean} textNode 是否考虑文本节点，默认为false\n   * @returns 下一个节点\n   */\n  next(node, textNode = false) {\n    if (textNode) {\n      return node.nextSibling;\n    } else {\n      let next = node.nextSibling;\n      while (next.nodeType !== 1) {\n        next = next.nextSibling;\n      }\n      return next;\n    }\n  },\n\n  /** previous\n   * 获取一个节点的上一个兄弟节点\n   * @param {Node} node 要操作的节点\n   * @param {boolean} textNode 是否考虑文本节点，默认为false\n   * @returns 上一个节点\n   */\n  previous(node, textNode = false) {\n    if (textNode) {\n      return node.previousSibling;\n    } else {\n      let prev = node.previousSibling;\n      while (prev.nodeType !== 1) {\n        prev = prev.previousSibling;\n      }\n      return prev;\n    }\n  },\n\n  /** each\n   * 遍历一个节点下的所有子节点，每次遍历到新元素可以对该元素执行一个函数\n   * @param {*} nodeList 节点组成的数组或伪数组\n   * @param {*} fn 回调函数\n   */\n  each(nodeList, fn, textNode = false) {\n    let children = nodeList;\n    for (let i = 0; i < children.length; i++) {\n      fn.call(null, children[i]);\n    }\n  },\n\n  /** index\n   * 计算该节点是其父节点下的第几个子节点\n   * @param {Node} node 一个节点\n   * @param {boolean} textNode 是否考虑文本节点，默认为false\n   * @returns 该节点是其父节点下的第几个子节点，计数从1开始。\n   */\n  index(node, textNode = false) {\n    let index = 0,\n      indexWithText = 0;\n    children = node.parentNode.childNodes;\n    for (let i = 0; i < children.length; i++) {\n      indexWithText++;\n      if (children[i].nodeType === 1) {\n        index++;\n      }\n      if (children[i] === node) {\n        break;\n      }\n    }\n    return textNode ? indexWithText : index;\n  },\n};\n\nconsole.log(\"iQuery加载完毕\");\n"]}